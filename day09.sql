-- PLAYER테이블에서 송종국선수가 속한 팀의 전화번호 검색하기
SELECT * FROM PLAYER;
SELECT * FROM TEAM;

SELECT P.TEAM_ID, T.TEAM_NAME, T.TEL
FROM PLAYER "P" JOIN TEAM "T" ON T.TEAM_ID = P.TEAM_ID AND P.PLAYER_NAME = '송종국';

-- JOBS 테이블에서 JOB_ID로  JOBS테이블의 JOB_TITLE,EMPLOYEES의 EMAIL, 성, 이름 검색하기
-- 성과 이름은 연결로 하나의 컬럼처럼 조회하기
SELECT * FROM JOBS;
SELECT * FROM EMPLOYEES;

SELECT J.JOB_TITLE, E.EMAIL, E.LAST_NAME||''|| E.FIRST_NAME "NAME"
FROM JOBS "J" JOIN EMPLOYEES "E" ON J.JOB_ID = E.JOB_ID;

-- 급여로 등급나누기
SELECT * FROM SALGRADE;
SELECT * FROM EMP;

-- 방법1
SELECT E.EMPNO, E.ENAME, S.GRADE, E.SAL
FROM SALGRADE "S" JOIN EMP "E"
ON E.SAL BETWEEN S.LOSAL AND S.HISAL; -- (SAL >= LOSAL, SAL <= HISAL) 비등가조인

-- 방법2	(WHERE을 사용하려면 JOIN을 지우고 , 를 넣어준다)
SELECT E.EMPNO, E.ENAME, S.GRADE, E.SAL
FROM SALGRADE "S", EMP "E"
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

-- EMPLOYEES 테이블에서HIRE_DATE 2003~ 2005년 가지인 사원의 정보를
-- HIRE_DATE, FIRST_NAME, DEPERTMENT_NAME 으로 조회
SELECT * FROM EMPLOYEES;
SELECT * FROM DEPARTMENTS;

SELECT E.HIRE_DATE, E.FIRST_NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES "E" JOIN DEPARTMENTS "D"
ON E.HIRE_DATE BETWEEN TO_DATE('2003-01','YYYY-MM')AND TO_DATE('2005-12','YYYY-MM') 
AND E.DEPARTMENT_ID = D.DEPARTMENT_ID;

SELECT * FROM EMP JOIN DEPT
ON EMP.DEPTNO = DEPT.DEPTNO;

-- USING() : 중복되는 컬럼이 생길시 맨 앞으로 출력하며 중복 컬럼을 한 개만 출력한다.
SELECT * FROM EMP JOIN DEPT USING(DEPTNO);

-- 내츄럴 조인(NATURAL JOIN)
-- INNER JOIN과 다르게 조건을 명시하지 않아도 두 테이블간 동일한 이름의 컬럼을
-- 자동으로 찾아 조인한다.
-- 컬럼의 이름 뿐만 아니라 타입이 모두 같아야한다.

SELECT * FROM EMP E NATURAL JOIN DEPT D; -- USING을 쓴 것과 같은 효과

-- LEFT OUTER JOIN
SELECT * FROM STADIUM; 	-- 데이터 20개
SELECT * FROM TEAM;		-- 데이터 15개

-- NULL값은 제외하고 검색이 된다.
SELECT * FROM STADIUM JOIN TEAM ON HOMETEAM_ID = TEAM_ID;

-- LEFT OUTER JOIN
-- 왼쪽에 써진 테이블을 기준으로 데이터의 개수를 맞춘다.
SELECT * FROM STADIUM LEFT OUTER JOIN TEAM ON HOMETEAM_ID = TEAM_ID;  	-- 데이터 20개 빈자리는 NULL로 채워진다.
SELECT * FROM TEAM LEFT OUTER JOIN STADIUM ON HOMETEAM_ID = TEAM_ID;	-- 데이터 15개

-- RIGHT OUTER JOIN
-- 오른쪽에 써진 테이블을 기준으로 데이터의 개수를 맞춘다 하지만 데이터 순서는 왼쪽부터 나타난다
SELECT * FROM TEAM RIGHT OUTER JOIN STADIUM ON HOMETEAM_ID = TEAM_ID;

-- FULL OUTER JOIN
-- 좌측 테이블과 우측 테이블의 데이터를 모두 읽어서 중복되는 데이터는 제거한 JOIN 결과를 보여준다.
SELECT * FROM TEAM FULL OUTER JOIN STADIUM ON HOMETEAM_ID = TEAM_ID;

-- SELF JOIN
SELECT * FROM EMP;

-- 매니저의 이름을 조회하기
SELECT * FROM EMP "E1" JOIN EMP "E2" ON E1.MGR  = E2.EMPNO;
--SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO, E2.ENAME, E2.MGR FROM EMP "E1" JOIN EMP "E2" ON E1.MGR  = E2.EMPNO;

-- 사원의 이름 조회하기
SELECT E1.ENAME "사원", E2.ENAME "매니저"
FROM EMP "E1" JOIN EMP "E2" ON E1.MGR  = E2.EMPNO;


SELECT * FROM PLAYER;

SELECT  ROUND((SYSDATE - BIRTH_DATE)/365) "AGE", P.* FROM PLAYER "P";

CREATE VIEW PLAYER_AGE 
AS (SELECT  ROUND((SYSDATE - BIRTH_DATE)/365) "AGE", P.* FROM PLAYER "P");

SELECT * FROM PLAYER_AGE;

-- VIEW 지우고 싶을 때
DROP VIEW PLAYER_AGE;

-- PLAYER테이블에 TEAM_NAME을 앞에다 추가한 VIEW 만들기
-- VIEW 이름 : PLAYER_TEAM_NAME

SELECT * FROM PLAYER;
SELECT * FROM TEAM;

SELECT T.TEAM_NAME, P.*
FROM PLAYER "P" JOIN TEAM "T" ON P.TEAM_ID = T.TEAM_ID;

CREATE VIEW PLAYER_TEAM_NAME
AS (SELECT T.TEAM_NAME, P.* FROM PLAYER "P" JOIN TEAM "T" ON P.TEAM_ID = T.TEAM_ID);

SELECT * FROM PLAYER_TEAM_NAME;

-- TEAM_NAME이 울산현대인 선수 조회하기
SELECT PLAYER_NAME, BACK_NO FROM PLAYER_TEAM_NAME
WHERE TEAM_NAME = '울산현대';

-- HOMETEAM_ID, STADIUM_NAME, TEAM_NAME을 조회하되
-- HOMETEAM이 없는 경기장 이름도 검색하고 VIEW로 만들기

-- VIEW 이름 : STADIUM_INFO

-- 그리고 VIEW에서 TEAM_NAME이 NULL인 경기장 검색하기



SELECT * FROM STADIUM;
SELECT * FROM TEAM;

SELECT S.HOMETEAM_ID, S.STADIUM_NAME, T.TEAM_NAME FROM STADIUM "S" FULL OUTER JOIN TEAM "T"
ON S.STADIUM_ID = T.STADIUM_ID;

CREATE VIEW STADIUM_INFO
AS (SELECT S.HOMETEAM_ID, S.STADIUM_NAME, T.TEAM_NAME FROM STADIUM "S" FULL OUTER JOIN TEAM "T"
ON S.STADIUM_ID = T.STADIUM_ID);

SELECT STADIUM_NAME, HOMETEAM_ID FROM STADIUM_INFO
WHERE HOMETEAM_ID IS NULL;















