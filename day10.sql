BEGIN			-- PUT_LINE('HELLO') : 오라클이 제공하는 프로시저
	DBMS_OUTPUT.PUT_LINE('HELLO'); -- 콘솔 영역에 출력을 해주는 프로시저
END;

-- F(X) = 2X + 1;

CREATE OR REPLACE PROCEDURE F
(
	X IN NUMBER
)
IS -- IS 영역에다가 연산을 하는 내용을 적으면 된다
BEGIN
	DBMS_OUTPUT.PUT_LINE(2*X+1);	
END;

CALL F(3);

-----------------

SELECT * FROM JOBS; --4개의 컬럼을 가지고 있는걸 확인

CREATE OR REPLACE PROCEDURE MY_NEW_JOB_PROC
(
	P_JOB_ID IN JOBS.JOB_ID%TYPE, -- JOB_ID의 타입을 그대로 따라가겠다.
	P_JOB_TITLE IN JOBS.JOB_TITLE%TYPE,
	P_MIN_SALARY IN JOBS.MIN_SALARY%TYPE,
	P_MAX_SALARY IN JOBS.MAX_SALARY%TYPE
)
IS
BEGIN
	INSERT INTO JOBS(JOB_ID, JOB_TITLE, MIN_SALARY, MAX_SALARY)
	VALUES(P_JOB_ID, P_JOB_TITLE, P_MIN_SALARY, P_MAX_SALARY);
	DBMS_OUTPUT.PUT_LINE('ALL DONE ABOUT'||' '||P_JOB_ID);
END;

CALL MY_NEW_JOB_PROC('IT','DEVELOPER',140000,20000);

-- PL/SQL문

-- 점수에 맞는 학점 출력하기
/*
 	DECLARE BEGIN END = PL / SQL 기본으로 쿼리, 문법을 실행할 수 있습니다.
 	DECLARE [선언부] - 변수, 상수를 선언할 수 있습니다.
 	BEGIN [실행부] - 제어, 반복문, 함수 등 다양한 로직 기술을 실행합니다.
 	END [종료부] - 실행된 로직의 종료를 선언합니다.
 	실행한 결과는 콘솔에서 확인할 수 있습니다.
*/

DECLARE 
	-- 변수 : 데이터를 담는 그릇
	SCORE NUMBER := 80; -- 80이라는 데이터를  SCORE라고 하는 변수에 대입
	GRADE VARCHAR2(5); -- 비어있는 그릇
BEGIN
	IF SCORE >= 90 THEN GRADE := 'A';
	ELSIF SCORE >= 80 THEN GRADE := 'B';
	ELSIF SCORE >= 70 THEN GRADE := 'C';
	ELSIF SCORE >= 60 THEN GRADE := 'D';
	ELSE GRADE := 'F';
	END IF;								-- CHR(10) 아스키코드 10 -> 줄을 바꿔주는 코드
	DBMS_OUTPUT.PUT_LINE('당신의 점수: '||SCORE||'점'||CHR(10)||'학점:'||GRADE);
END;

-----------------------------------

CREATE OR REPLACE PROCEDURE GET_GRADE
(
	SCORE NUMBER
)
IS
	GRADE VARCHAR2(5); --자료형만 지정하는 이유는 학점을 미리 정할 수 없기 때문
BEGIN
	IF SCORE >= 90 THEN GRADE := 'A';
	ELSIF SCORE >= 80 THEN GRADE := 'B';
	ELSIF SCORE >= 70 THEN GRADE := 'C';
	ELSIF SCORE >= 60 THEN GRADE := 'D';
	ELSE GRADE := 'F';
	END IF;								
	DBMS_OUTPUT.PUT_LINE('당신의 점수: '||SCORE||'점'||CHR(10)||'학점:'||GRADE);
END;

CALL GET_GRADE(78);

-- 1부터 100까지의 총합

DECLARE
	NUM NUMBER := 1; -- 시작값
	TOTAL NUMBER := 0; -- 더한값을 누적시켜줄 그릇
BEGIN
	WHILE NUM <= 100
	LOOP
		TOTAL := TOTAL + NUM;
		NUM := NUM+1;
	END LOOP;
	DBMS_OUTPUT.PUT_LINE('1~100까지의 총합: 'TOTAL);
END;

-- WHILE 조건식
-- LOOP
-- 반복하고자 하는 명령
-- END LOOP;

-- 1부터 N까지의 총합

CREATE OR REPLACE PROCEDURE TOTAL_PROC
(
	P_NUM NUMBER -- 마지막값 N
)
IS 
	NUM NUMBER := 1;
	TOTAL NUMBER := 0;
BEGIN
	WHILE NUM <= P_NUM
	LOOP
		TOTAL := TOTAL + NUM;
		NUM := NUM+1;
	END LOOP;
	DBMS_OUTPUT.PUT_LINE('1~'||P_NUM||'까지의 총합: ' ||TOTAL);
END;

CALL TOTAL_PROC(10);

---------------------------------------------------------

CREATE OR REPLACE PROCEDURE MY_NEW_JOB_PROC
(	-- (변수) IN 테이블 . 컬럼%TYPE
	P_JOB_ID IN JOBS.JOB_ID%TYPE, -- JOB_ID의 타입을 그대로 따라가겠다.
	P_JOB_TITLE IN JOBS.JOB_TITLE%TYPE,
	P_MIN_SALARY IN JOBS.MIN_SALARY%TYPE,
	P_MAX_SALARY IN JOBS.MAX_SALARY%TYPE
)
IS
	CNT NUMBER := 0; --CNT 라는 빈공간을 만들어준다
BEGIN
	SELECT COUNT(JOB_ID) INTO CNT -- JOBS로부터 COUNT를 했다면CNT변수에 저장을 해줘.
	FROM JOBS WHERE JOB_ID = P_JOB_ID;

	IF CNT = 0 THEN -- P_JOB_ID과 중복되는 이름의 자료가 없다면!(0)
		INSERT INTO JOBS(JOB_ID, JOB_TITLE, MIN_SALARY, MAX_SALARY)
		VALUES(P_JOB_ID, P_JOB_TITLE, P_MIN_SALARY, P_MAX_SALARY);
		DBMS_OUTPUT.PUT_LINE('ALL DONE ABOUT'||' '||P_JOB_ID);
	
	ELSE -- P_JOB_ID과 중복되는 이름의 자료가 있다면!(1)
		UPDATE JOBS
		SET
		JOB_TITLE = P_JOB_TITLE,
		MIN_SALARY = P_MIN_SALARY,
		MAX_SALARY = P_MAX_SALARY
		WHERE JOB_ID = P_JOB_ID;
		DBMS_OUTPUT.PUT_LINE('ALL DONE ABOUT'||' '||P_JOB_ID);
	END IF;
END;

CALL MY_NEW_JOB_PROC('IT','DEVELOPER',5000,1000);
SELECT * FROM JOBS;

-- 제거를 하기 위한 프로시저 만들기
CREATE OR REPLACE PROCEDURE DEL_JOB_PROC
(
	P_JOB_ID IN JOBS.JOB_ID%TYPE
)
IS
	CNT NUMBER := 0;
BEGIN
	SELECT COUNT(JOB_ID) INTO CNT
	FROM JOBS WHERE JOB_ID = P_JOB_ID;
	IF CNT != 0 THEN 
		DELETE FROM JOBS 
		WHERE JOB_ID = P_JOB_ID;
		DBMS_OUTPUT.PUT_LINE('DLELTE ALL DONE ABOUT'||' '||P_JOB_ID);
	ELSE
		DBMS_OUTPUT.PUT_LINE('NO EXIST ABOUT'||' '||P_JOB_ID);
	END IF;
END;

CALL DEL_JOB_PROC ('IT');
SELECT * FROM JOBS;

CREATE TABLE MEMO(
	NUM NUMBER PRIMARY KEY,
	SUBJECT VARCHAR2(50)
);


CREATE SEQUENCE MEMO_SEQ;

INSERT INTO MEMO VALUES(MEMO_SEQ.NEXTVAL, '제목1');
INSERT INTO MEMO VALUES(MEMO_SEQ.NEXTVAL, '제목2');
INSERT INTO MEMO VALUES(MEMO_SEQ.NEXTVAL, '제목3');
INSERT INTO MEMO VALUES(MEMO_SEQ.NEXTVAL, '제목4');
INSERT INTO MEMO VALUES(MEMO_SEQ.NEXTVAL, '제목5');
INSERT INTO MEMO VALUES(MEMO_SEQ.NEXTVAL, '제목6');
INSERT INTO MEMO VALUES(MEMO_SEQ.NEXTVAL, '제목7');
INSERT INTO MEMO VALUES(MEMO_SEQ.NEXTVAL, '제목8');

SELECT * FROM MEMO;







